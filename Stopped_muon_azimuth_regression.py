{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import sklearn as sk\n",
    "from sklearn.model_selection import train_test_split\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import roc_curve\n",
    "from sklearn.metrics import auc\n",
    "from tcn import TCN\n",
    "from tensorflow import keras\n",
    "import tensorflow as tf\n",
    "from sklearn import metrics\n",
    "import sqlite3\n",
    "import time\n",
    "import pickle as pkl\n",
    "\n",
    "with tf.device('/GPU:0'):\n",
    "\n",
    "    #################################\n",
    "    # Load events                   #\n",
    "    #################################\n",
    "    with open('train_events.pkl','rb') as f:\n",
    "        train_events = pkl.load(f)\n",
    "    \n",
    "    with open('validation_events.pkl','rb') as f:\n",
    "        validation_events = pkl.load(f)\n",
    "        \n",
    "        \n",
    "    \n",
    "    #################################\n",
    "    # train function                #\n",
    "    #################################\n",
    "    #Should do the same as model.fit but works better for our model\n",
    "    def Train(model, batches):\n",
    "        Training_Losses = []\n",
    "        Training_auc_scores = []\n",
    "        for epoch in range(n_epochs):\n",
    "            epoch_loss = 0\n",
    "            print('TRAINING EPOCH: %s / %s'%(epoch+1, n_epochs))\n",
    "            \n",
    "            for batch in batches:\n",
    "                batch_loss = model.train_on_batch(x = batch[0], y = batch[1])            \n",
    "                Training_Losses.append(batch_loss)\n",
    "                epoch_loss += batch_loss\n",
    "                \n",
    "    \n",
    "            \n",
    "            print('epoch loss: ', epoch_loss)\n",
    "            model.save('Model_at_epoch'+str(epoch+0))\n",
    "            with open('Loss_at_'+str(epoch+0)+'.pkl','wb') as f:\n",
    "                pkl.dump(Training_Losses, f)\n",
    "            \n",
    "        print('training done!')\n",
    "        return model, Training_Losses\n",
    "    \n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Model                         #\n",
    "    #################################\n",
    "    def tcn_model_26(max_length, N_filters,kernel_size, output_dim):\n",
    "        i = tf.keras.Input(batch_shape = (None, max_length,7))\n",
    "        o = TCN(\n",
    "            nb_filters = N_filters,\n",
    "            kernel_size = kernel_size,\n",
    "            dropout_rate = 0.001,\n",
    "            return_sequences = False,\n",
    "            activation = 'elu',\n",
    "         )(i)\n",
    "        o = tf.keras.layers.Dense(N_filters, activation = tf.keras.layers.LeakyReLU)(o) \n",
    "        o = tf.keras.layers.Dropout(0.01)(o)\n",
    "        o = tf.keras.layers.Dense(N_filters, activation = tf.keras.layers.LeakyReLU)(o)\n",
    "        \n",
    "        o = tf.keras.layers.Dense(output_dim)(o)\n",
    "        model = tf.keras.models.Model(inputs=[i], outputs=[o],activation='tanh')\n",
    "        return model\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Parameters                    #\n",
    "    #################################\n",
    "    \n",
    "    n_filters = 32\n",
    "    kernel_size = 3 \n",
    "    output_dim = 2\n",
    "    lr = 1e-3\n",
    "    batch_size = 1000\n",
    "    n_epochs = 100\n",
    "    max_event_size = 250\n",
    "    max_length = 250\n",
    "    db_file = filename\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Homemade loss function        #\n",
    "    #################################\n",
    "    def sincosloss(y_true, y_pred):\n",
    "        \n",
    "        thetruth = tf.math.atan2(y_true[:,0], y_true[:,1])\n",
    "        thepred = tf.math.atan2(y_pred[:,0], y_pred[:,1])\n",
    "        co = 1- tf.math.cos(thetruth-thepred)\n",
    "        co = tf.reduce_sum(co)\n",
    "        \n",
    "        return co\n",
    "    \n",
    "    #################################\n",
    "    # Compiling model               #\n",
    "    #################################\n",
    "    model = tcn_model_26(max_length, n_filters, kernel_size, output_dim)\n",
    "    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=lr), loss = sincosloss)\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Model loader for further training  #\n",
    "    #################################\n",
    "    #model.load_weights('saved_path_to_model')\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Training                      #\n",
    "    #################################\n",
    "    print('starting training')\n",
    "    start = time.time()    \n",
    "    trained_model, loss = Train(model, train_events, validation_events)\n",
    "    \n",
    "    end = time.time()\n",
    "    print(round(end-start,3),'sec')\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Prediction function           #\n",
    "    #################################\n",
    "    def Predict(model, batches):#, batch_size):\n",
    "        predictions = []\n",
    "        truth = []\n",
    "        for event_batch in batches:\n",
    "            out = model.predict(event_batch[0])\n",
    "            predictions.extend(out)\n",
    "            truth.extend(event_batch[1])\n",
    "        print('prediction done!')\n",
    "        return predictions, truth\n",
    "    \n",
    "    \n",
    "    #################################\n",
    "    # Predicting                    #\n",
    "    #################################\n",
    "    print('Starting prediction')\n",
    "    start = time.time()\n",
    "    \n",
    "    pred,truth  = Predict(trained_model, validation_events)#, batch_size)\n",
    "    \n",
    "    end = time.time()\n",
    "    \n",
    "    print(round(end-start,3),'sec')\n",
    "    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
